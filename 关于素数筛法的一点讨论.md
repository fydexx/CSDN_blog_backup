前言
--
在数论领域，解决问题时经常会有得到素数的需求
如何快速得到一定范围内的所有素数，就成了人们一直追求的问题
这里列举一些素数筛法，也许会有帮助

埃氏筛法(Sieve of Eratosthenes)
------------------
笔者在最早接触数论时，就学到的算法
思路比较简单：
对于每个素数，都枚举其倍数打上标记
那么没打过标记的就都是素数了
示例程序：

```
for (int i=2;i<=n;i++)
 if (!vis[i]){
 	for (int j=i+i;j<=n;j+=i) vis[j]=1;
 	p[++p[0]]=i;
 }
```
可以证明，时间复杂度为$O(nloglogn)$

欧拉筛（线性筛）
--------
上面的方法虽然简单，但是效率略低
这里实现一种更为高效的筛法：
```
for (int i=2;i<=n;i++){
	if (!vis[i]) p[++p[0]]=i;
	for (int j=1;j<=p[0]&&i*p[j]<=n;j++){
		vis[i*p[j]]=1;
		if (i%p[j]==0) break;
	}
}
```
这看起来一点也不线性，别急，且看分析：
下面证明【每个合数被且仅被标记过一次】
只要此命题成立，就能同时说明 算法的正确性 与 时间复杂度的线性

设当前数字为 $i=p^{k_1}_1×p^{k_2}_2……p^{k_n}_n$（$p_1≤p_2≤……≤p_n$）
则通过i标记的数为 $p^{k_1+1}_1×p^{k_2}_2……p^{k_n}_n$或$p×p^{k_1}_1×p^{k_2}_2……p^{k_n}_n$
（可以通过反证法得到 $p≤p_1$）
把思维转换一下，设合数 $j=p^{k_1}_1×p^{k_2}_2……p^{k_n}_n$
那么j只可能通过 $p^{k_1-1}_1×p^{k_2}_2……p^{k_n}_n$这个数被标记，而且这个数一定存在
那么就可以说明【每个合数被且仅被标记过一次】了

综上所述，时间复杂度$O(n)$
