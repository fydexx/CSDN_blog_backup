前言
--

昨天帮Sdywolf查代码……
解法和标算一模一样，而且看不出常数大的地方，但是就是TLE了
经过一番检验，发现竟然是读优的问题！

正文
--

原来的读优一直调用getchar()……
以为挺快的，没想到会TLE
Manchery大神自己定义了一个与getchar()功能相似的函数：
```
inline char nc(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
```
这里简略地解释一下：
这个函数主要的原理是利用fread()来加速读入
fread()的4个参数依次是：本次读入的起始指针，单位空间的字节数，要读入的单位数，读入的文件流
并且返回读入成功的单位数

先定义了一个缓存空间buf[]，以及一头一尾两个指针
每次判断，如果缓存空间有内容，就返回一个char
如果缓存空间没有了，就再次fread()填满整个缓存空间
如果读入失败，就说明是文件末尾

实验证明，基于nc()的读优比基于getchar()的读优快了近4倍！（极端条件下）

注意事项
----
切记：不要与scanf()混用！因为文件流的一些内容可能已经被加载到缓存空间里了
不过在第一次使用fread()之前还是可以scanf()的